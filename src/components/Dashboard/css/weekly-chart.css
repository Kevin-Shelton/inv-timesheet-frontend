import React, { useState, useEffect } from 'react';
import { supabase } from '../../supabaseClient.js';
import { useAuth } from '../../hooks/useAuth';

const TrackedHoursChart = () => {
  const { user, canViewAllTimesheets } = useAuth();
  const [chartData, setChartData] = useState({
    workedHours: { total: 0, daily: [] },
    breaks: { total: 0, daily: [] },
    overtimeHours: { total: 0, daily: [] }
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Get current week dates with proper validation
  const getCurrentWeekDates = () => {
    try {
      const today = new Date();
      
      // Validate that today is a valid date
      if (isNaN(today.getTime())) {
        console.error('ðŸ“Š WEEKLY CHART ERROR: Invalid current date');
        // Fallback to a known good date
        const fallbackDate = new Date('2025-01-20');
        return getWeekDatesFromDate(fallbackDate);
      }
      
      return getWeekDatesFromDate(today);
    } catch (error) {
      console.error('ðŸ“Š WEEKLY CHART ERROR: Error getting current week dates:', error);
      // Return a fallback week
      const fallbackDate = new Date('2025-01-20');
      return getWeekDatesFromDate(fallbackDate);
    }
  };

  const getWeekDatesFromDate = (baseDate) => {
    try {
      const currentDay = baseDate.getDay();
      const monday = new Date(baseDate);
      
      // Calculate Monday of the current week (Sunday = 0, Monday = 1)
      const daysToMonday = currentDay === 0 ? -6 : 1 - currentDay;
      monday.setDate(baseDate.getDate() + daysToMonday);
      
      const weekDates = [];
      for (let i = 0; i < 7; i++) {
        const date = new Date(monday);
        date.setDate(monday.getDate() + i);
        
        // Validate each date before adding
        if (isNaN(date.getTime())) {
          console.error(`ðŸ“Š WEEKLY CHART ERROR: Invalid date for day ${i}`);
          // Create a fallback date
          const fallbackDate = new Date(2025, 0, 20 + i); // January 20-26, 2025
          weekDates.push(fallbackDate);
        } else {
          weekDates.push(date);
        }
      }
      return weekDates;
    } catch (error) {
      console.error('ðŸ“Š WEEKLY CHART ERROR: Error creating week dates:', error);
      // Return a complete fallback week
      return [
        new Date(2025, 0, 20), // Monday
        new Date(2025, 0, 21), // Tuesday
        new Date(2025, 0, 22), // Wednesday
        new Date(2025, 0, 23), // Thursday
        new Date(2025, 0, 24), // Friday
        new Date(2025, 0, 25), // Saturday
        new Date(2025, 0, 26)  // Sunday
      ];
    }
  };

  const weekDates = getCurrentWeekDates();
  const dayLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

  useEffect(() => {
    fetchTimesheetData();
  }, [user]);

  const fetchTimesheetData = async () => {
    if (!user) return;

    try {
      setLoading(true);
      setError(null);

      // Validate weekDates before using toISOString
      const validatedWeekDates = weekDates.map((date, index) => {
        if (isNaN(date.getTime())) {
          console.error(`ðŸ“Š WEEKLY CHART ERROR: Invalid date at index ${index}:`, date);
          // Return a fallback date
          return new Date(2025, 0, 20 + index);
        }
        return date;
      });

      const startDate = validatedWeekDates[0].toISOString().split('T')[0];
      const endDate = validatedWeekDates[6].toISOString().split('T')[0];

      console.log('ðŸ“Š WEEKLY CHART: Fetching data for week:', startDate, 'to', endDate);

      // Fetch timesheet entries with explicit relationship specification
      let query = supabase
        .from('timesheet_entries')
        .select('*') // Just select timesheet data first
        .gte('date', startDate)
        .lte('date', endDate)
        .order('date', { ascending: true });

      // If user can't view all timesheets, only show their own
      if (!canViewAllTimesheets()) {
        query = query.eq('user_id', user.id);
      }

      const { data: entries, error: fetchError } = await query;

      if (fetchError) {
        console.error('ðŸ“Š WEEKLY CHART ERROR:', fetchError);
        throw fetchError;
      }

      console.log('ðŸ“Š WEEKLY CHART: Fetched entries:', entries?.length || 0);

      // Process data
      const processedData = processTimesheetData(entries || [], validatedWeekDates);
      setChartData(processedData);

    } catch (error) {
      console.error('ðŸ“Š WEEKLY CHART ERROR:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  const processTimesheetData = (entries, validatedWeekDates) => {
    const chartData = {
      workedHours: { total: 0, daily: new Array(7).fill(0) },
      breaks: { total: 0, daily: new Array(7).fill(0) },
      overtimeHours: { total: 0, daily: new Array(7).fill(0) }
    };

    entries.forEach(entry => {
      try {
        const entryDate = new Date(entry.date);
        
        // Validate entry date
        if (isNaN(entryDate.getTime())) {
          console.error('ðŸ“Š WEEKLY CHART ERROR: Invalid entry date:', entry.date);
          return; // Skip this entry
        }

        const dayIndex = validatedWeekDates.findIndex(date => {
          try {
            return date.toDateString() === entryDate.toDateString();
          } catch (error) {
            console.error('ðŸ“Š WEEKLY CHART ERROR: Error comparing dates:', error);
            return false;
          }
        });

        if (dayIndex !== -1) {
          // Use existing calculated values or fall back to total hours
          const regular = parseFloat(entry.regular_hours) || 0;
          const overtime = parseFloat(entry.overtime_hours) || parseFloat(entry.daily_overtime_hours) || 0;
          const totalHours = parseFloat(entry.total_hours) || parseFloat(entry.hours_worked) || (regular + overtime);
          const breakTime = parseFloat(entry.break_duration) || 0;

          // Add to daily totals
          chartData.workedHours.daily[dayIndex] += totalHours;
          chartData.breaks.daily[dayIndex] += breakTime;
          chartData.overtimeHours.daily[dayIndex] += overtime;

          // Add to weekly totals
          chartData.workedHours.total += totalHours;
          chartData.breaks.total += breakTime;
          chartData.overtimeHours.total += overtime;
        }
      } catch (entryError) {
        console.error('ðŸ“Š WEEKLY CHART ERROR: Error processing entry:', entryError, entry);
      }
    });

    console.log('ðŸ“Š WEEKLY CHART: Final chart data:', chartData);
    return chartData;
  };

  // Inline styles for the chart
  const styles = {
    trackedHoursChart: {
      backgroundColor: '#fff',
      borderRadius: '8px',
      padding: '20px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
      marginBottom: '20px'
    },
    chartHeader: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: '20px'
    },
    chartTitle: {
      fontSize: '18px',
      fontWeight: '600',
      color: '#333',
      margin: 0
    },
    chartLegend: {
      display: 'flex',
      gap: '20px'
    },
    legendItem: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
      fontSize: '14px',
      color: '#666'
    },
    legendColor: {
      width: '12px',
      height: '12px',
      borderRadius: '50%'
    },
    legendWorked: {
      backgroundColor: '#3b82f6'
    },
    legendBreaks: {
      backgroundColor: '#10b981'
    },
    legendOvertime: {
      backgroundColor: '#f59e0b'
    },
    chartContainer: {
      marginBottom: '20px'
    },
    chartBars: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'end',
      height: '200px',
      padding: '20px 0',
      borderBottom: '2px solid #e5e7eb',
      gap: '8px'
    },
    dayColumn: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      flex: 1,
      height: '100%'
    },
    dayLabel: {
      fontSize: '12px',
      fontWeight: '500',
      color: '#666',
      marginBottom: '8px'
    },
    barContainer: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'end',
      height: '140px',
      width: '100%',
      position: 'relative',
      gap: '2px'
    },
    bar: {
      width: '100%',
      maxWidth: '40px',
      borderRadius: '4px 4px 0 0',
      display: 'flex',
      alignItems: 'end',
      justifyContent: 'center',
      color: '#fff',
      fontSize: '10px',
      fontWeight: '500',
      minHeight: '4px',
      position: 'relative'
    },
    barWorked: {
      backgroundColor: '#3b82f6'
    },
    barBreaks: {
      backgroundColor: '#10b981'
    },
    barOvertime: {
      backgroundColor: '#f59e0b'
    },
    barValue: {
      position: 'absolute',
      bottom: '2px',
      fontSize: '10px',
      fontWeight: '500',
      color: '#fff',
      textShadow: '0 1px 2px rgba(0,0,0,0.5)'
    },
    dayDetails: {
      marginTop: '8px',
      textAlign: 'center'
    },
    totalHours: {
      fontSize: '12px',
      fontWeight: '600',
      color: '#333'
    },
    overtimeIndicator: {
      fontSize: '10px',
      color: '#f59e0b',
      fontWeight: '500'
    },
    chartSummary: {
      display: 'flex',
      justifyContent: 'space-around',
      padding: '16px',
      backgroundColor: '#f9fafb',
      borderRadius: '6px',
      gap: '20px'
    },
    summaryItem: {
      textAlign: 'center'
    },
    summaryLabel: {
      display: 'block',
      fontSize: '12px',
      color: '#666',
      marginBottom: '4px'
    },
    summaryValue: {
      fontSize: '16px',
      fontWeight: '600',
      color: '#333'
    },
    summaryValueOvertime: {
      color: '#f59e0b'
    },
    loading: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      height: '200px',
      color: '#666'
    },
    error: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      height: '200px',
      color: '#dc2626'
    },
    retryButton: {
      marginTop: '10px',
      padding: '8px 16px',
      backgroundColor: '#3b82f6',
      color: '#fff',
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer'
    }
  };

  if (loading) {
    return (
      <div style={{...styles.trackedHoursChart, ...styles.loading}}>
        <div>Loading tracked hours...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div style={{...styles.trackedHoursChart, ...styles.error}}>
        <div>Error Loading Chart</div>
        <div>{error}</div>
        <button style={styles.retryButton} onClick={fetchTimesheetData}>
          Retry
        </button>
      </div>
    );
  }

  // Calculate max value for chart scaling
  const maxValue = Math.max(
    ...chartData.workedHours.daily,
    ...chartData.breaks.daily,
    ...chartData.overtimeHours.daily,
    1 // Minimum value to prevent division by zero
  );

  return (
    <div style={styles.trackedHoursChart}>
      <div style={styles.chartHeader}>
        <h3 style={styles.chartTitle}>Tracked Hours This Week</h3>
        <div style={styles.chartLegend}>
          <div style={styles.legendItem}>
            <span style={{...styles.legendColor, ...styles.legendWorked}}></span>
            <span>Worked Hours</span>
          </div>
          <div style={styles.legendItem}>
            <span style={{...styles.legendColor, ...styles.legendBreaks}}></span>
            <span>Break Time</span>
          </div>
          <div style={styles.legendItem}>
            <span style={{...styles.legendColor, ...styles.legendOvertime}}></span>
            <span>Overtime</span>
          </div>
        </div>
      </div>

      <div style={styles.chartContainer}>
        <div style={styles.chartBars}>
          {dayLabels.map((day, index) => {
            const workedHeight = maxValue > 0 ? Math.max((chartData.workedHours.daily[index] / maxValue) * 120, chartData.workedHours.daily[index] > 0 ? 8 : 0) : 0;
            const breakHeight = maxValue > 0 ? Math.max((chartData.breaks.daily[index] / maxValue) * 120, chartData.breaks.daily[index] > 0 ? 4 : 0) : 0;
            const overtimeHeight = maxValue > 0 ? Math.max((chartData.overtimeHours.daily[index] / maxValue) * 120, chartData.overtimeHours.daily[index] > 0 ? 6 : 0) : 0;

            const hasOvertime = chartData.overtimeHours.daily[index] > 0;

            return (
              <div key={day} style={styles.dayColumn}>
                <div style={styles.dayLabel}>{day}</div>
                <div style={styles.barContainer}>
                  {/* Worked Hours Bar */}
                  {chartData.workedHours.daily[index] > 0 && (
                    <div 
                      style={{
                        ...styles.bar,
                        ...styles.barWorked,
                        height: `${workedHeight}px`
                      }}
                      title={`Worked: ${chartData.workedHours.daily[index].toFixed(1)}h`}
                    >
                      <span style={styles.barValue}>
                        {chartData.workedHours.daily[index].toFixed(1)}
                      </span>
                    </div>
                  )}
                  
                  {/* Break Time Bar */}
                  {chartData.breaks.daily[index] > 0 && (
                    <div 
                      style={{
                        ...styles.bar,
                        ...styles.barBreaks,
                        height: `${breakHeight}px`
                      }}
                      title={`Breaks: ${chartData.breaks.daily[index].toFixed(1)}h`}
                    >
                      <span style={styles.barValue}>
                        B: {chartData.breaks.daily[index].toFixed(1)}
                      </span>
                    </div>
                  )}
                  
                  {/* Overtime Bar */}
                  {hasOvertime && (
                    <div 
                      style={{
                        ...styles.bar,
                        ...styles.barOvertime,
                        height: `${overtimeHeight}px`
                      }}
                      title={`Overtime: ${chartData.overtimeHours.daily[index].toFixed(1)}h`}
                    >
                      <span style={styles.barValue}>
                        OT: {chartData.overtimeHours.daily[index].toFixed(1)}
                      </span>
                    </div>
                  )}
                </div>
                
                {/* Day Details */}
                <div style={styles.dayDetails}>
                  <div style={styles.totalHours}>
                    {chartData.workedHours.daily[index].toFixed(1)}h
                  </div>
                  {hasOvertime && (
                    <div style={styles.overtimeIndicator}>
                      OT: {chartData.overtimeHours.daily[index].toFixed(1)}h
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      <div style={styles.chartSummary}>
        <div style={styles.summaryItem}>
          <span style={styles.summaryLabel}>Total Worked:</span>
          <span style={styles.summaryValue}>{chartData.workedHours.total.toFixed(1)}h</span>
        </div>
        <div style={styles.summaryItem}>
          <span style={styles.summaryLabel}>Total Breaks:</span>
          <span style={styles.summaryValue}>{chartData.breaks.total.toFixed(1)}h</span>
        </div>
        <div style={styles.summaryItem}>
          <span style={styles.summaryLabel}>Total Overtime:</span>
          <span style={{...styles.summaryValue, ...styles.summaryValueOvertime}}>
            {chartData.overtimeHours.total.toFixed(1)}h
          </span>
        </div>
      </div>
    </div>
  );
};

export default TrackedHoursChart;

